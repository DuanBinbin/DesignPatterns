# 设计模式与游戏完美开发-蔡升达

## 第二篇 基础系统

### 03.游戏场景的转换-状态模式(State)

定义：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。

参考文档：

[【游戏设计模式】之三 状态模式、有限状态机 & Unity版本实现 ](https://blog.csdn.net/poem_qianmo/article/details/52824776)

### 04.游戏主要类-外观模式(Facade)

定义：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

别名：门面模式

理解：

* 该类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性

拓展：

1. 思考：外观模式(也称为”门面模式“)与中介者模式的区别：

   > 门面模式是结构型模式，中介者模式是行为型模式。
   >
   > 门面模式是对子系统提供统一的接口,中介者模式是用一个中介对象来封装一系列同事对象的交互行为。
   >
   > 门面模式协议是单向，中介者模式协议是双向。
   >
   > 门面模式所有的请求处理都委托给子系统完成，而中介者模式则由中心协调同事类和中心本身共同完成业务。 

参考文档：

[设计模式之外观模式Facade](http://jenny-run.iteye.com/blog/2298529)

[23种设计模式(10)_结构型_外观模式（Facade Pattern）](http://www.voidcn.com/article/p-qmczzlns-ph.html)

### 05.获取游戏服务的唯一对象-单例模式(Singleton)

定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

其他应用方式:

* 网络在线游戏的客户端,可以使用单例模式(Singleton)来限制连接数,以预防误用而产生过多链接,避免服务器端因此失效
* 日志工具是比较不受项目类型影响的功能之一,所以可以设计为跨项目共享使用.此外,日志工具大多使用在调试或重要信息的输出上,而单例模式(Singleton)能让程序设计师方便快速的获取日志工具,所以是个不错的设计方式

### 06.游戏内各系统的整合-中介者模式(Mediator)

定义：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

别名：调停者模式

理解：

* 同事类：

  > 有两个类A和B，类中各有一个数字，并且要保证类B中的数字永远是类A中数字的100倍。也就是说，当修改类A的数时，将这个数字乘以100赋给类B，而修改类B时，要将数除以100赋给类A。类A类B互相影响，就称为同事类。

* 中介者模式存在的理由：

  > 就是把原来处理对象关系的代码重新封装到一个中介类中，通过这个中介类来处理对象间的关系。

其他应用方式：

- 网络引擎:连线管理系统与网络数据封包管理系统之间,如果可以通过中介者模式(Mediator)进行沟通,那么就能轻松地针对连线管理系统抽换所使用地通信方式(TCP或UDP).
- 数据库引擎:内部可以分成数个子系统,有专门负责数据库连接地功能与产生数据库操作语句地功能,两个子功能之间地沟通可以通过中介者模式(Mediator)来进行,让两者之间不相互依赖,方便抽换另一个子系统

参考文档：

[23种设计模式（7）：中介者模式 ](https://blog.csdn.net/zhengzhb/article/details/7430098)

### 07.游戏的主循环-Game Loop

## 第三篇 角色的设计

### 08.角色系统的设计分析

### 09.角色与武器的实现-桥接模式(Bridege)

**定义**：将抽象部分与它的实现部分分离，使它们都可以独立地变化。

**理解**：

* 什么叫抽象与它的实现分离，这并不是说，让抽象与其派生类分离，因为这没有任何意义。实现指的是抽象类和它的派生类用来实现自己的对象。 --还是不理解？
* 桥接模式把两个角色之间的继承关系改为聚合关系，从而使二者可以各自独立的变化。把原来在基类的实现化细节抽象出来，再构造到一个实现化的结构中，然后把原来的基类改造成一个抽象化的等级结构，这样就实现了系统在多个维度上的独立变化。 

![img](https://wizardforcel.gitbooks.io/design-pattern-lessons/content/img/bridgePattern0.png) 

**拓展**：



**其他应用方式**：

* 游戏角色可以驾驶不同的行动载具，如汽车，飞机，水上摩托车......
* 奇幻类型游戏的角色可以施展法术，除了多样的角色之外，"法术"本身也是另外一个复杂的系统，火系法术，冰系法术......，远程法术，近战法术、补血法术......,想额外加上限制的话，就必须使用桥接模式(Bridge)让角色与法术类群组妥善组合

参考文档：

[桥接模式(Bridge Pattern)](https://wizardforcel.gitbooks.io/design-pattern-lessons/content/lesson22.html)

> 讲清楚了什么是桥接模式，但是没有具体的应该例子



### 10.角色属性的计算-策略模式(Strategy)

定义：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化。

别名：政策模式(Policy)

类型：对象行为模式

理解：

* 定义一组封装起来的算法，在算法拥有者中可以改变算法

拓展：

* 策略模式与简单工程模式的异同点：

  > 相似点：都是利用多态的性质 
  >
  > 区别点：
  >
  > 简单工厂模式：传条件进工厂类，工厂类就会返回一个创建的对象给调用者使用；策略模式：传一个要使用的策略实例对象给策略模式的Context类，然后调用Context类中的方法  	

其他应用方式:

- 有些角色扮演型游戏(RPG)的属性系统,会使用"转换计算"的方式来获取角色最终要使用的属性.例如:玩家看到角色界面上只会显示"体力","力量","敏捷"......,但实际在运用攻击计算时,这些属性会被再转换为"生命力","攻击力","闪避率".......而之所以会这样设计的原因在于,该游戏有"职业"的设置,对于不同的"职业",在计算转换时会有不同的转换方式,利用策略模式(Strategy)将这些转换公式独立出来是比较好的.
- 游戏角色操作载具时,会引用角色当前对该类型载具的累积时间,并将之转换为"操控性",操控性越好,就越能控制该载具.而获取操控性的计算公式,也可以利用策略模式(Strategy)将其独立出来
- 网络在线游戏往往需要玩家注册账号,注册账号有多种方式,例如OpenID(Facebook,Google+),自建账号,随机产生等.通过策略模式(Strategy)可以将不同账号的注册方式独立为不同的登录策略.这样做,除了可以强化项目的维护,也可以方便转换到不同的游戏项目上,增加重复利用的价值.

参考文档:

[策略模式(strategy pattern)](https://www.jianshu.com/p/d0c1b312d563)

> 清楚的说明了策略模式的原理

[策略模式](https://wizardforcel.gitbooks.io/design-pattern-lessons/content/lesson2.html)

> 策略模式跟简单工厂模式的搭配使用

### 11.攻击特效与中击反应-模板方法模式(Template Method)

定义：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

其他应用方式：

* 奇幻类角色扮演游戏(RPG)，对于游戏角色要施展一个法术时，会有许多特定的检查条件，如魔力是否足够，否是还在冷却时间内，对象是否在法术施展范围内等。如果这些检查条件会按照施展法术的类型而有所不同，那么就可以使用模板方法模式（Template Method）将检查流程固定下来，真正检查的功能则交给各法术子类去实现。另外，一个法术的施展流程和击中计算也可以如同本章范例一样，将流程固定下来，细节交给各法术子类去实现。
* 在线游戏的角色登录,也可以使用模板方法模式(Template Method)将登录流程固定下来,例如:显示登录画面,选择登录方法,输入账号密码,向Server请求登录等,然后将登录功能的子类去重新实现其中的步骤.另外,也可以实现不同的登录流程样板来对应不同的登录方式(OpenID,自动创建,快速登录等)

参考文档：

[模版方法模式(Template method pattern)](https://wizardforcel.gitbooks.io/design-pattern-lessons/content/lesson12.html)

[攻击特效与击中反应-模板方法模式(Template Method)](http://www.cnblogs.com/revoid/p/6475481.html)



### 12.角色AI-状态模式(State)

### 13.角色系统

## 第四篇 角色的产生

### 14.游戏角色的产生-工厂方法模式(Factory Method)

### 15.角色的组装-建造者模式(Builder)

### 16.游戏属性管理功能-享元模式(Flyweight)

### 

## 第五篇 战争开始

### 17.Unity3D的界面设计-组合模式(Composite)

### 18.兵营系统以及兵营信息显示

### 19.兵营训练单位-命令模式(Command)

### 20.关卡设计-责任链(Chain of Responsibility)

## 第六篇 辅助系统

### 21.成就系统-观察者模式(Observer)

### 22.存盘功能-备忘录模式(Memento)

### 23.角色信息查询-访问者模式(Visitor)

## 第七篇 调整和优化

### 24.前缀字尾-装饰模式(Decorator)

### 25.俘兵-适配器模式(Adaptor)

### 26.加速度优化-代理模式(Proxy)

## 第八篇 未明确使用的模式

### 27.迭代器模式(Iterator)、原型模式(Prototype)和解释器模式(Interpreter)

### 28.抽象工厂模式(Abstract Factory)

## 参考文档：

[随笔分类 - 设计模式与游戏完美开发](http://www.cnblogs.com/revoid/category/954799.html)

[Unity-Design-Pattern](https://github.com/QianMo/Unity-Design-Pattern)

[图说设计模式](http://design-patterns.readthedocs.io/zh_CN/latest/index.html)

[设计模式](https://blog.csdn.net/column/details/pattern.html)

[设计模式包教不包会](https://legacy.gitbook.com/book/wizardforcel/design-pattern-lessons/details)

> 名字说的很恰当，只有理论没有实践，但是能够把原理讲清楚也已经很不错了






